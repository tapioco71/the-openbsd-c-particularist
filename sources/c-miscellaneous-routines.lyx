#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass memoir
\use_default_options true
\master the-openbsd-c-particularist.lyx
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.7cm
\topmargin 1cm
\rightmargin 1.5cm
\bottommargin 1.2cm
\headheight 1cm
\headsep 1cm
\footskip 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "chap:miscellaneous-routines"

\end_inset

Miscellaneous Routines.
\end_layout

\begin_layout Standard
\align right
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:resource-limits"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:obtaining-resource-usage-information"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:manipulating-byte-strings"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:environment-variables"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:the-current-working-directory"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:searching-for-characters-in-strings"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:determining-whether-a-file-is-a-terminal"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:printing-error-messages"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:sorting-arrays-in-memory"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:generating-random-numbers"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset ref
LatexCommand nameref
reference "sec:getting-parameters-from-console"
plural "false"
caps "false"
noprefix "false"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
This chapter describes some useful system calls and library routines whose
 description don't fit well into the previous chapters.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:resource-limits"

\end_inset

Resource Limits.
\end_layout

\begin_layout Standard
On OpenBSD each process operates with certain limits on the resources it
 may use.
 These limits prevent processes from creating files that are considered
 
\shape italic
too large
\shape default
, using too much CPU time and so on.
\end_layout

\begin_layout Subsection
The 
\family typewriter
getrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getrlimit
\end_layout

\end_inset


\family default
 and 
\family typewriter
setrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setrlimit
\end_layout

\end_inset


\family default
 System Call.
\end_layout

\begin_layout Standard
Limits on the consumption of system resources by the current process and
 each process it creates may be obtained with the 
\family typewriter
getrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getrlimit
\end_layout

\end_inset


\family default
 call and set with the 
\family typewriter
setrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setrlimit
\end_layout

\end_inset


\family default
 call.
 The first parameter of both system calls is one of the following:
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_CORE
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_CORE
\end_layout

\end_inset


\family default
 — the largest size (in bytes) core file that may be created;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_CPU
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_CPU
\end_layout

\end_inset


\family default
 — the maximum amount of CPU time (in seconds) to be used by each process;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_DATA
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_DATA
\end_layout

\end_inset


\family default
 — the maximum size, in bytes, of the data segment for a process; this includes
 memory allocated via 
\shape italic
malloc
\shape default
(3) and all other anonymous memory mapped via 
\shape italic
mmap
\shape default
(2);
\end_layout

\begin_layout Itemize
RLIMIT_FSIZE
\begin_inset Index idx
status open

\begin_layout Plain Layout
RLIMIT_FSIZE
\end_layout

\end_inset

 — the largest size (in bytes) file that may be created;
\end_layout

\begin_layout Itemize
RLIMIT_MEMLOCK
\begin_inset Index idx
status open

\begin_layout Plain Layout
RLIMIT_MEMLOCK
\end_layout

\end_inset

 — the maximum size, in bytes, which a process may lock into memory using
 the 
\shape italic
mlock
\shape default
(2) function;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_NOFILE
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_NOFILE
\end_layout

\end_inset


\family default
 — the maximum number of open files for this process;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_NPROC
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_NPROC
\end_layout

\end_inset


\family default
 — the maximum number of simultaneous processes for this user id;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_RSS
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout

\family typewriter
RLIMIT_RSS
\end_layout

\end_inset


\family default
 — the maximum size, in bytes, to which a process's resident set size may
 grow.
 This setting is no longer enforced, but retained for compatibility;
\end_layout

\begin_layout Itemize

\family typewriter
RLIMIT_STACK
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIMIT_STACK
\end_layout

\end_inset


\family default
 — the maximum size (in bytes) of the stack segment for a process, which
 defines how far a process's stack segment may be extended.
 Stack extension is performed automatically by the system, and is only used
 by the main thread of a process;
\end_layout

\begin_layout Standard
\noindent
A 
\shape italic
resource limit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\shape italic
resource limit
\end_layout

\end_inset


\shape default
 is specified as a 
\shape italic
soft limit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\shape italic
soft limit
\end_layout

\end_inset


\shape default
 and a 
\shape italic
hard limit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\shape italic
hard limit
\end_layout

\end_inset


\shape default
.
 When a soft limit is exceeded a process may receive a signal
\begin_inset Foot
status open

\begin_layout Plain Layout
\noindent
For example, if the CPU time or file size is exceeded.
\end_layout

\end_inset

, but it will be allowed to continue execution until it reaches the hard
 limit or modifies its resource limit.
 The 
\family typewriter
rlimit
\family default
 structure
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
rlimit
\family default
 structure
\end_layout

\end_inset

 is used to specify the hard and soft limits on a resource:
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:rlimit-struct"

\end_inset

The rlimit structure.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

struct rlimit {
\end_layout

\begin_layout Plain Layout

	rlim_t rlim_cur;
\end_layout

\begin_layout Plain Layout

	rlim_t rlim_max;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The members are:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
\series bold
rlim_cur
\family default
\series default
 current (soft) limit;
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\family typewriter
\series bold
rlim_max
\family default
\series default
 hard limit.
\end_layout

\begin_layout Standard
Only the super-user
\begin_inset Index idx
status open

\begin_layout Plain Layout
super-user
\end_layout

\end_inset

 may raise the maximum limits.
 Other users may only alter 
\family typewriter
rlim_cur
\family default
 within the range from 0 to 
\family typewriter
rlim_max
\family default
 or, irreversibly, lower 
\family typewriter
rlim_max
\family default
.
 An 
\shape italic
infinite
\shape default
 value for a limit is defined as 
\family typewriter
RLIM_INFINITY
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIM_INFINITY
\end_layout

\end_inset


\family default
.
 A value of 
\family typewriter
RLIM_SAVED_CUR
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIM_SAVED_CUR
\end_layout

\end_inset


\family default
 or 
\family typewriter
RLIM_SAVED_MAX
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIM_SAVED_MAX
\end_layout

\end_inset


\family default
 will be stored in 
\family typewriter
rlim_cur
\family default
 or 
\family typewriter
rlim_max
\family default
 respectively by 
\family typewriter
getrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getrlimit
\end_layout

\end_inset


\family default
 if the value for the current or maximum resource limit cannot be stored
 in an 
\family typewriter
rlim_t
\family default
.
 The values 
\family typewriter
RLIM_SAVED_CUR
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIM_SAVED_CUR
\end_layout

\end_inset


\family default
 and 
\family typewriter
RLIM_SAVED_MAX
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RLIM_SAVED_MAX
\end_layout

\end_inset


\family default
 should not be used in a call to 
\family typewriter
setrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setrlimit
\end_layout

\end_inset


\family default
 unless they were returned by a previous call to 
\family typewriter
getrlimit
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getrlimit
\end_layout

\end_inset


\family default
.
 Because this information is stored in the per-process information, this
 system call must be executed directly by the shell if it is to affect all
 future processes created by the shell; limit is thus a built-in command
 to 
\shape italic
csh
\shape default
(1) and ulimit is the 
\shape italic
sh
\shape default
(1) equivalent.
 The system refuses to extend the data or stack space when the limits would
 be exceeded in the normal way: a 
\shape italic
brk
\shape default
(2) call fails if the data space limit is reached.
 When the stack limit is reached, the process receives a segmentation fault
 (
\family typewriter
SIGSEGV
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
SIGSEGV
\end_layout

\end_inset


\family default
); if this signal is not caught by a handler using the signal stack, this
 signal will kill the process.
 A file I/O operation that would create a file larger than the process'
 soft limit will cause the write to fail and a signal 
\family typewriter
SIGXFSZ
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
SIGXFSZ
\end_layout

\end_inset


\family default
 to be generated; this normally terminates the process, but may be caught.
 When the soft CPU time limit is exceeded, a signal 
\family typewriter
SIGXCPU
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
SIGXCPU
\end_layout

\end_inset


\family default
 is sent to the offending process.
 Upon successful completion, the value 0 is returned; otherwise the value
 -1 is returned and the global variable 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 The usual method to change resource limits is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "c:setlim"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:setlim"

\end_inset

setlim - change resource limits.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File setlim.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdbool.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include <sys/types.h>
\end_layout

\begin_layout Plain Layout

#include <sys/time.h>
\end_layout

\begin_layout Plain Layout

#include <sys/resource.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* setlim program.
 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions protitypes.
 */
\end_layout

\begin_layout Plain Layout

long int setlim(int, rlim_t);
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	bool ok = false;
\end_layout

\begin_layout Plain Layout

	char *bad;
\end_layout

\begin_layout Plain Layout

	int limit;
\end_layout

\begin_layout Plain Layout

	long int ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	rlim_t value;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* Checks arguments.
 */
\end_layout

\begin_layout Plain Layout

	if(argc == 3) {
\end_layout

\begin_layout Plain Layout

		ok = true;
\end_layout

\begin_layout Plain Layout

		if(strncmp(argv[ 1 ], "cpu", 3) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_CPU;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "filesize", 8) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_FSIZE;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "data", 4) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_DATA;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "stack", 5) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_STACK;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "core", 4) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_CORE;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "rss", 3) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_RSS;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "memorylock", 10) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_MEMLOCK;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "nproc", 5) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_NPROC;
\end_layout

\begin_layout Plain Layout

		else if(strncmp(argv[ 1 ], "openfiles", 9) == 0)
\end_layout

\begin_layout Plain Layout

			limit = RLIMIT_NOFILE;
\end_layout

\begin_layout Plain Layout

		else {
\end_layout

\begin_layout Plain Layout

			ok = false;
\end_layout

\begin_layout Plain Layout

			perror("unknown limit");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		if(ok == true) {
\end_layout

\begin_layout Plain Layout

			if(strncmp(argv[ 2 ], "infinity", 8) == 0)
\end_layout

\begin_layout Plain Layout

				value = RLIM_INFINITY;
\end_layout

\begin_layout Plain Layout

			else {
\end_layout

\begin_layout Plain Layout

				value = (rlim_t) strtoul(argv[ 2 ], &bad, 0);
\end_layout

\begin_layout Plain Layout

				if(*bad != '
\backslash
0') {
\end_layout

\begin_layout Plain Layout

					ok = false;
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			if(ok == true) {
\end_layout

\begin_layout Plain Layout

				printf("set limit: %s(%d)
\backslash
tto value: %lld
\backslash
n", argv[ 1 ], limit,   value);
\end_layout

\begin_layout Plain Layout

				if(setlim(limit, value) == EXIT_SUCCESS)
\end_layout

\begin_layout Plain Layout

					ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

				else
\end_layout

\begin_layout Plain Layout

					perror("error setting limit");
\end_layout

\begin_layout Plain Layout

			} else
\end_layout

\begin_layout Plain Layout

				perror("bad numerical value for limit");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	} else
\end_layout

\begin_layout Plain Layout

		fprintf(stderr, "usage: setlim <limit> <value>
\backslash
n");
\end_layout

\begin_layout Plain Layout

	exit(ret);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

 * setlim -- set the limit for the process.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

long int setlim(int lim, rlim_t val)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	long int ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	struct rlimit rlim;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/*
\end_layout

\begin_layout Plain Layout

	 * Get the current limits so  we
\end_layout

\begin_layout Plain Layout

	 * will know the maximum value.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

	bzero(&rlim, sizeof(struct rlimit));
\end_layout

\begin_layout Plain Layout

	if(getrlimit(lim, &rlim) >= 0) {
\end_layout

\begin_layout Plain Layout

		printf("current limit: %lld
\backslash
tmaximum limit: %lld
\backslash
n", rlim.rlim_cur, rlim.rlim_max);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		/* Now change the current limit.
 */
\end_layout

\begin_layout Plain Layout

		rlim.rlim_cur = val;
\end_layout

\begin_layout Plain Layout

		if(setrlimit(lim, &rlim) >= 0)
\end_layout

\begin_layout Plain Layout

			ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return ret;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of setlim.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:obtaining-resource-usage-information"

\end_inset

Obtaining Resource Usage Information.
\end_layout

\begin_layout Standard
\noindent
OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 allows user to take tracks of resources usage on the system.
 To achieve that a data structure and a system call were provided and defined
 in 
\family typewriter
<sys/resource.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<sys/resource.h>
\end_layout

\end_inset


\family default
.
 
\family typewriter
getrusage
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getrusage
\end_layout

\end_inset


\family default
 returns resource usage information and takes two arguments.
 The first for argument, which can be one of the following:
\end_layout

\begin_layout Itemize

\family typewriter
RUSAGE_SELF
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RUSAGE_SELF
\end_layout

\end_inset


\family default
 — resources used by the current process;
\end_layout

\begin_layout Itemize

\family typewriter
RUSAGE_CHILDREN
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RUSAGE_CHILDREN
\end_layout

\end_inset


\family default
 — resources used by all the terminated children of the current process;
\end_layout

\begin_layout Itemize

\family typewriter
RUSAGE_THREAD
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
RUSAGE_THREAD
\end_layout

\end_inset


\family default
 — resources used by the current thread.
\end_layout

\begin_layout Standard
The buffer to which the second argument points will be filled in with the
 following structure
\begin_inset Index idx
status open

\begin_layout Plain Layout
rusage structure
\end_layout

\end_inset

:
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:rusage-struct"

\end_inset

The rusage structure.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

struct rusage {
\end_layout

\begin_layout Plain Layout

	struct timeval ru_utime;
\end_layout

\begin_layout Plain Layout

	struct timeval ru_stime;
\end_layout

\begin_layout Plain Layout

	long ru_maxrss;
\end_layout

\begin_layout Plain Layout

	long ru_ixrss;
\end_layout

\begin_layout Plain Layout

	long ru_idrss;
\end_layout

\begin_layout Plain Layout

	long ru_isrss;
\end_layout

\begin_layout Plain Layout

	long ru_minflt;
\end_layout

\begin_layout Plain Layout

	long ru_majflt;
\end_layout

\begin_layout Plain Layout

	long ru_nswap;
\end_layout

\begin_layout Plain Layout

	long ru_inblock;
\end_layout

\begin_layout Plain Layout

	long ru_oublock;
\end_layout

\begin_layout Plain Layout

	long ru_msgsnd;
\end_layout

\begin_layout Plain Layout

	long ru_msgrcv;
\end_layout

\begin_layout Plain Layout

	long ru_nsignals;
\end_layout

\begin_layout Plain Layout

	long ru_nvcsw;
\end_layout

\begin_layout Plain Layout

	long ru_nivcsw;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The fields are interpreted as follows:
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000
\noindent

\family typewriter
\series bold
ru_utime
\family default
\series default
 the total amount of time spent executing in user mode;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_stime
\family default
\series default
 the total amount of time spent in the system executing on behalf of the
 process(es);
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_maxrss
\family default
\series default
 the maximum resident set size utilized, in kilobytes;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_ixrss
\family default
\series default
 an "integral" value indicating the amount of memory used by the text segment
 that was also shared among other processes.
 This value is expressed in units of kilobytes * ticks-of- execution;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_idrss
\family default
\series default
 an integral value of the amount of unshared memory residing in the data
 segment of a process, expressed in units of kilobytes * ticks-of-execution;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000
\noindent

\family typewriter
\series bold
ru_isrss
\family default
\series default
 an integral value of the amount of unshared memory residing in the stack
 segment of a process, expressed in units of kilobytes * ticks-of-execution;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_minflt
\family default
\series default
 the number of page faults serviced without any I/O activity; here I/O activity
 is avoided by 
\shape italic
reclaiming
\shape default
 a page frame from the list of pages awaiting reallocation;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_majflt
\family default
\series default
 the number of page faults serviced that required I/O activity;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_nswap
\family default
\series default
 the number of times a process was 
\shape italic
swapped
\shape default
 out of main memory;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000
\noindent

\family typewriter
\series bold
ru_inblock
\family default
\series default
 the number of times the file system had to perform input;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_oublock
\family default
\series default
 the number of times the file system had to perform output;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_msgsnd
\family default
\series default
 the number of ipc messages sent;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_msgrcv
\family default
\series default
 the number of ipc messages received;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000

\family typewriter
\series bold
ru_nsignals
\family default
\series default
 the number of signals delivered;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000
\noindent

\family typewriter
\series bold
ru_nvcsw
\family default
\series default
 the number of times a context switch resulted due to a process voluntarily
 giving up the processor before its time slice was completed, usually to
 await availability of a resource;
\end_layout

\begin_layout Labeling
\labelwidthstring 0000.0000.0000
\noindent

\family typewriter
\series bold
ru_nivcsw
\family default
\series default
 the number of times a context switch resulted due to a higher priority
 process becoming runnable or because the current process exceeded its time
 slice.
\end_layout

\begin_layout Standard
\noindent
The numbers 
\family typewriter
ru_inblock
\family default
 and 
\family typewriter
ru_oublock
\family default
 account only for real I/O; data supplied by the caching mechanism is charged
 only to the first process to read or write the data.
 Upon successful completion, the value 0 is returned; otherwise the value
 -1 is returned and the global variable 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "c:rusage"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the usage data for the rusage program itself.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:rusage"

\end_inset

rusage - get usage data for the process itself.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File rusage.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdbool.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include <sys/types.h>
\end_layout

\begin_layout Plain Layout

#include <sys/time.h>
\end_layout

\begin_layout Plain Layout

#include <sys/resource.h>
\end_layout

\begin_layout Plain Layout
\noindent

\end_layout

\begin_layout Plain Layout

/* rusage program.
 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions protitypes.
 */
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	long int ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	struct rusage usage;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* */
\end_layout

\begin_layout Plain Layout

	if(getrusage(RUSAGE_SELF, &usage) >= 0) {
\end_layout

\begin_layout Plain Layout

		printf("user time used: %ld s
\backslash
n", (time_t) usage.ru_utime.tv_sec);
\end_layout

\begin_layout Plain Layout

		printf("system time used: %ld s
\backslash
n", (time_t) usage.ru_stime.tv_sec);
\end_layout

\begin_layout Plain Layout

		printf("maximum resident set size: %ld kB
\backslash
n", usage.ru_maxrss);
\end_layout

\begin_layout Plain Layout

		printf("integral shared text memory size: %ld kBt
\backslash
n", usage.ru_ixrss);
\end_layout

\begin_layout Plain Layout

		printf("integral unshared data size: %ld kBt
\backslash
n", usage.ru_idrss);
\end_layout

\begin_layout Plain Layout

		printf("integral unshared stack size: %ld kBt
\backslash
n", usage.ru_isrss);
\end_layout

\begin_layout Plain Layout

		printf("page reclaims: %ld
\backslash
n", usage.ru_minflt);
\end_layout

\begin_layout Plain Layout

		printf("page faults: %ld
\backslash
n", usage.ru_majflt);
\end_layout

\begin_layout Plain Layout

		printf("swaps: %ld
\backslash
n", usage.ru_nswap);
\end_layout

\begin_layout Plain Layout

		printf("block input operations: %ld
\backslash
n", usage.ru_inblock);
\end_layout

\begin_layout Plain Layout

		printf("block output operations: %ld
\backslash
n", usage.ru_oublock);
\end_layout

\begin_layout Plain Layout

		printf("messages sent: %ld
\backslash
n", usage.ru_msgsnd);
\end_layout

\begin_layout Plain Layout

		printf("messages received: %ld
\backslash
n", usage.ru_msgrcv);
\end_layout

\begin_layout Plain Layout

		printf("signals received: %ld
\backslash
n", usage.ru_nsignals);
\end_layout

\begin_layout Plain Layout

		printf("voluntary context switches: %ld
\backslash
n", usage.ru_nvcsw);
\end_layout

\begin_layout Plain Layout

		printf("involuntary context switches: %ld
\backslash
n", usage.ru_nivcsw);
\end_layout

\begin_layout Plain Layout

		ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	exit(ret);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of rusage.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:manipulating-byte-strings"

\end_inset

Manipulating Byte Strings.
\end_layout

\begin_layout Standard
Most users know the 
\family typewriter
strcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strcmp
\end_layout

\end_inset


\family default
, 
\family typewriter
strcpy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strcpy
\end_layout

\end_inset


\family default
, 
\family typewriter
strncmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strncmp
\end_layout

\end_inset


\family default
 and 
\family typewriter
strncpy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strncpy
\end_layout

\end_inset


\family default
 routines, they work fine for NUL terminated strings of characters.
 They do not fit for generic usage, where we have to deal with arrays of
 non-printing characters such as '
\backslash
0'.
 In that case, we could use 
\family typewriter
bcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcmp
\end_layout

\end_inset


\family default
, 
\family typewriter
bcopy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcopy
\end_layout

\end_inset


\family default
, 
\family typewriter
bzero
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bzero
\end_layout

\end_inset


\family default
, 
\family typewriter
memcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcmp
\end_layout

\end_inset


\family default
, 
\family typewriter
memcpy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcpy
\end_layout

\end_inset


\family default
, 
\family typewriter
memmove
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memmove
\end_layout

\end_inset


\family default
 and 
\family typewriter
memset
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memset
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsection
The 
\family typewriter
bcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcmp
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
bcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcmp
\end_layout

\end_inset


\family default
 function takes three arguments.
 It compares byte pointed by the first parameter against byte string pointed
 by the second argument, returning zero if they are identical, non-zero
 otherwise.
 Both strings are assumed to be of length in bytes as specified in the third
 argument.
 Zero-length strings are always identical.
 The strings may overlap.
\end_layout

\begin_layout Subsection
The 
\family typewriter
bcopy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcopy
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
bcopy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bcopy
\end_layout

\end_inset


\family default
 routine takes three arguments.
 It copies a number of bytes as specified in the third argument from the
 buffer pointed by the first argument to the buffer pointed by the second
 argument.
 The two buffers may overlap.
 If the length specified in the third argument is zero, no bytes are copied.
\end_layout

\begin_layout Subsection
The 
\family typewriter
bzero
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bzero
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
bzero
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
bzero
\end_layout

\end_inset


\family default
 routine takes two arguments.
 It writes a number, specified in the second argument, of zero bytes to
 the string pointed by the first argument.
 If the length in the second argument is zero, 
\family typewriter
bzero
\family default
 does nothing.
 The 
\family typewriter
explicit_bzero
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
explicit_bzero
\end_layout

\end_inset


\family default
 variant behaves the same, but will not be removed by a compiler's dead
 store optimization pass, making it useful for clearing sensitive memory
 such as a password.
\end_layout

\begin_layout Subsection
The 
\family typewriter
memcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcmp
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
memcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcmp
\end_layout

\end_inset


\family default
 function takes three arguments.
 It compares byte in the string, pointed by the first argument, against
 byte string, pointed by the second argument.
 Both strings are assumed to be of length specified in the third argument.
 The 
\family typewriter
memcmp
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcmp
\end_layout

\end_inset


\family default
 function returns zero if the two strings are identical otherwise returns
 the difference between the first two differing bytes, treated as 
\family typewriter
unsigned char
\family default
 values, so that '
\backslash
200' is greater than '
\backslash
0', for example.
 Zero-length strings are always identical.
\end_layout

\begin_layout Subsection
The 
\family typewriter
memcpy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcpy
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
memcpy
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memcpy
\end_layout

\end_inset


\family default
 routine takes three arguments.
 The memcpy function copies a number of bytes, specified by the third argument,
 from buffer pointed by the second argument, to buffer pointed by the first
 argument.
 If the two buffers may overlap, 
\shape italic
memmove
\shape default
(3) must be used instead.
 The memcpy function returns the original value of the first argument.
\end_layout

\begin_layout Subsection
The 
\family typewriter
memmove
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memmove
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
memmove
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memmove
\end_layout

\end_inset


\family default
 function takes three arguments.
 It copies the number of bytes, specified in the third argument, bytes from
 the buffer pointed by the second argument to the buffer pointed by the
 first argument.
 The two buffers may overlap; the copy is always done in a non-destructive
 manner.
 The 
\family typewriter
memmove
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memmove
\end_layout

\end_inset


\family default
 function returns the original value of the first argument.
\end_layout

\begin_layout Subsection
The 
\family typewriter
memset
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memset
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
memset
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
memset
\end_layout

\end_inset


\family default
 function takes three arguments.
 It writes a count of bytes, as specified in the third argument, of the
 same value of the second argument, converted to an 
\family typewriter
unsigned char
\family default
, to the string pointed by the first argument.
 The 
\family typewriter
memset
\family default
 function returns the original value of the first argument.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:environment-variables"

\end_inset

Environment Variables.
\end_layout

\begin_layout Standard
To handle environment variables, OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 provides a set of system routines: 
\family typewriter
getenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getenv
\end_layout

\end_inset


\family default
, 
\family typewriter
setenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setenv
\end_layout

\end_inset


\family default
, 
\family typewriter
putenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
putenv
\end_layout

\end_inset


\family default
 and 
\family typewriter
unsetenv
\family default
.
 These functions set, unset, and fetch environment variables from the host
 environment list.
 The 
\family typewriter
getenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getenv
\end_layout

\end_inset


\family default
 function obtains the current value of the environment variable name.
 If the variable name is not in the current environment, a null pointer
 is returned.
 The 
\family typewriter
setenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setenv
\end_layout

\end_inset


\family default
 function inserts or resets the environment variable name in the current
 environment list.
 If the variable name does not exist in the list, it is inserted with the
 given value.
 If the variable does exist, the argument overwrite is tested; if overwrite
 is zero, the variable is not reset, otherwise it is reset to the given
 value.
 The 
\family typewriter
putenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
putenv
\end_layout

\end_inset


\family default
 function takes an argument of the form name=value.
 The memory pointed to by string becomes part of the environment and must
 not be deallocated by the caller.
 If the variable already exists, it will be overwritten.
 A common source of bugs is to pass a string argument that is a locally
 scoped string buffer.
 This will result in corruption of the environment after leaving the scope
 in which the variable is defined.
 For this reason, the 
\family typewriter
setenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setenv
\end_layout

\end_inset


\family default
 function is preferred over 
\family typewriter
putenv
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
putenv
\end_layout

\end_inset

.
 The 
\family typewriter
unsetenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
unsetenv
\end_layout

\end_inset


\family default
 function deletes all instances of the variable name pointed to by name
 from the list.
 The 
\family typewriter
putenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
putenv
\end_layout

\end_inset


\family default
, 
\family typewriter
setenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
setenv
\end_layout

\end_inset


\family default
 and 
\family typewriter
unsetenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
unsetenv
\end_layout

\end_inset


\family default
 functions return the value 0 if successful; otherwise the value -1 is returned
 and the global variable 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 The 
\family typewriter
getenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getenv
\end_layout

\end_inset


\family default
 function returns a pointer to the requested value, or NULL if it could
 not be found.
 If 
\family typewriter
getenv
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getenv
\end_layout

\end_inset


\family default
 is successful, the string returned should be considered read-only.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:the-current-working-directory"

\end_inset

The Current Working Directory.
\end_layout

\begin_layout Standard
OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 provides a function to return the current working directory to the user:
 
\family typewriter
getcwd
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getcwd
\end_layout

\end_inset


\family default
.
 The 
\family typewriter
getcwd
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getcwd
\end_layout

\end_inset


\family default
 function copies the absolute pathname of the current working directory
 into the memory referenced by the first argument and returns a pointer
 to the buffer.
 The second argument is the size, in bytes, of the array referenced by the
 buffer pointed by the first argument.
 If this pointer is not NULL and the length of the pathname plus the terminating
 NUL character is greater than the second argument, a null pointer is returned
 and 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to 
\family typewriter
ERANGE
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ERANGE
\end_layout

\end_inset


\family default
.
 As an extension to IEEE Std 1003.1-2001 ("POSIX.1"), if the first argument
 is NULL, space is allocated as necessary to store the pathname.
 In this case, it is the responsibility of the caller to 
\shape italic
free
\shape default
(3) the pointer that 
\family typewriter
getcwd
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
getcwd
\end_layout

\end_inset


\family default
 returns.
 Upon successful completion, a pointer to the pathname is returned.
 Otherwise a null pointer is returned and 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:searching-for-characters-in-strings"

\end_inset

Searching for Characters in Strings.
\end_layout

\begin_layout Standard
Two function are provided by OpenBSD to achieve character search in a NUL
 terminated string: 
\family typewriter
strchr
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strchr
\end_layout

\end_inset


\family default
 and 
\family typewriter
strrchr
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strrchr
\end_layout

\end_inset


\family default
 both defined in 
\family typewriter
<string.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<string.h>
\end_layout

\end_inset


\family default
 They takes two arguments: strchr locates the first occurrence, strrchr
 the last occurrence, of the character specified by the second argument,
 converted to a 
\family typewriter
char
\family default
, in the string pointed by the first argument.
 The terminating NUL character is considered part of the string itself.
 If the second argument is '
\backslash
0', 
\family typewriter
strchr
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strchr
\end_layout

\end_inset


\family default
 and 
\family typewriter
strrchr
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strrchr
\end_layout

\end_inset


\family default
 locate the terminating '
\backslash
0'.
 They returns a pointer to the located character or NULL if the character
 does not appear in the string.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:determining-whether-a-file-is-a-terminal"

\end_inset

Determining Whether a File is a Terminal.
\end_layout

\begin_layout Standard
OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 provides four functions: 
\family typewriter
ttyname
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname
\end_layout

\end_inset


\family default
, 
\family typewriter
ttyname_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname_r
\end_layout

\end_inset


\family default
, 
\family typewriter
isatty
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
isatty
\end_layout

\end_inset


\family default
 defined in 
\family typewriter
<unistd.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<unistd.h>
\end_layout

\end_inset


\family default
 and 
\family typewriter
ttyslot
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyslot
\end_layout

\end_inset


\family default
 defined in 
\family typewriter
<stdlib.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<stdlib.h>
\end_layout

\end_inset


\family default
.
 These functions operate on the system file descriptors for terminal type
 devices.
 These descriptors are not related to the standard I/O FILE typedef, but
 refer to the special device files found in 
\shape italic
/dev
\shape default
 and named 
\shape italic
/dev/ttyXX
\shape default
 and for which an entry exists in the initialization file 
\shape italic
/etc/ttys
\shape default
, see 
\shape italic
ttys
\shape default
(5).
 The 
\family typewriter
isatty
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
isatty
\end_layout

\end_inset


\family default
 function determines if the file descriptor in the first argument refers
 to a valid terminal type device.
 The 
\family typewriter
ttyname
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname
\end_layout

\end_inset


\family default
 and 
\family typewriter
ttyname_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname_r
\end_layout

\end_inset


\family default
 functions get the related device name of a file descriptor for which 
\family typewriter
isatty
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
isatty
\end_layout

\end_inset


\family default
 is true.
 The 
\family typewriter
ttyname_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname_r
\end_layout

\end_inset


\family default
 function stores the NUL-terminated pathname of the terminal associated
 with the file descriptor of the first argument in the character array reference
d by the second argument.
 The array length in bytes is specified in the third argument and should
 have space for the name and the terminating NUL character.
 The maximum length of the terminal name is 
\family typewriter
TTY_NAME_MAX
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
TTY_NAME_MAX
\end_layout

\end_inset


\family default
.
 The 
\family typewriter
ttyslot
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyslot
\end_layout

\end_inset


\family default
 function fetches the current process's controlling terminal number from
 the 
\shape italic
ttys
\shape default
(5) file entry.
 The 
\family typewriter
ttyname
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname
\end_layout

\end_inset


\family default
 function returns the NUL-terminated name if the device is found and 
\family typewriter
isatty
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
isatty
\end_layout

\end_inset


\family default
 is true; otherwise a null pointer is returned and 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 The 
\family typewriter
ttyname_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyname_r
\end_layout

\end_inset


\family default
 function returns zero if successful; otherwise an error number is returned.
 The 
\family typewriter
isatty
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
isatty
\end_layout

\end_inset


\family default
 function returns 1 if the file descriptor in the first argument is associated
 with a terminal device; otherwise it returns 0 and 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 The 
\family typewriter
ttyslot
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
ttyslot
\end_layout

\end_inset


\family default
 function returns the unit number of the device file if found; otherwise
 the value zero is returned.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:printing-error-messages"

\end_inset

Printing Error Messages.
\end_layout

\begin_layout Standard
OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 provides 
\family typewriter
perror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
perror
\end_layout

\end_inset


\family default
 
\family typewriter
psignal
\family default

\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
psignal
\end_layout

\end_inset

, 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 and 
\family typewriter
strsignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strsignal
\end_layout

\end_inset


\family default
 functions to help the user to deal with error conditions.
 
\family typewriter
perror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
perror
\end_layout

\end_inset


\family default
 function is defined in 
\family typewriter
<stdio.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<stdio.h>
\end_layout

\end_inset


\family default
, 
\family typewriter
psignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
psignal
\end_layout

\end_inset


\family default
 function in 
\family typewriter
<signal.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<signal.h>
\end_layout

\end_inset


\family default
, 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 and 
\family typewriter
strsignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strsignal
\end_layout

\end_inset


\family default
 functions in 
\family typewriter
<string.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<string.h>
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:perror-routine"

\end_inset

The 
\family typewriter
perror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
perror
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
perror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
perror
\end_layout

\end_inset


\family default
 function looks up the error message string affiliated with an error number
 and writes it, followed by a new-line, to the standard error stream.
 If the argument string is not the NULL pointer and is not zero length,
 it is prepended to the message string and separated from it by a colon
 and a space, ': '.
 Otherwise, only the error message string is printed.
 The contents of the error message string are the same as those returned
 by 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 with argument 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsection
The 
\family typewriter
psignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
psignal
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
psignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
psignal
\end_layout

\end_inset


\family default
 routine takes two arguments.
 It locates the descriptive message string for the given signal number in
 the first argument and writes it to the standard error.
 If the second argument is not NULL it is written to the standard error
 file descriptor prior to the message string, immediately followed by a
 colon and a space, ': '.
 If the signal number is not recognized, see 
\shape italic
sigaction
\shape default
(2) for a list, the string "Unknown signal" is produced.
 The message strings can be accessed directly using the external array 
\family typewriter
sys_siglist
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
sys_siglist
\end_layout

\end_inset


\family default
, indexed by recognized signal numbers.
 The external array 
\family typewriter
sys_signame
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
sys_signame
\end_layout

\end_inset


\family default
 is used similarly and contains short, upper-case abbreviations for signals
 which are useful for recognizing signal names in user input.
 The defined value 
\family typewriter
NSIG
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
NSIG
\end_layout

\end_inset


\family default
 contains a count of the strings in 
\family typewriter
sys_siglist
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
sys_siglist
\end_layout

\end_inset


\family default
 and 
\family typewriter
sys_signame
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
sys_signame
\end_layout

\end_inset


\family default
.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:strerror"

\end_inset

The 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
There are three versions of this function: 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
, 
\family typewriter
strerror_l
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_l
\end_layout

\end_inset


\family default
 and 
\family typewriter
strerror_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_r
\end_layout

\end_inset


\family default
.
 These functions map the error number specified in the first argument to
 an error message string.
 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 and 
\family typewriter
strerror_l
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_l
\end_layout

\end_inset


\family default
 return a string containing a maximum of 
\family typewriter
NL_TEXTMAX
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
NL_TEXTMAX
\end_layout

\end_inset


\family default
 characters, including the trailing NUL.
 This string is not to be modified by the calling program.
 The string returned by 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 may be overwritten by subsequent calls to 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 in any thread.
 The string returned by 
\family typewriter
strerror_l
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_l
\end_layout

\end_inset


\family default
 may be overwritten by subsequent calls to 
\family typewriter
strerror_l
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_l
\end_layout

\end_inset


\family default
 in the same thread.
 
\family typewriter
strerror_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_r
\end_layout

\end_inset


\family default
 is a thread safe version of 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 that places the error message in the specified buffer pointed by the second
 argument.
 On OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

, the global locale, the thread-specific locale, and the locale argument
 are ignored.
 
\family typewriter
strerror
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror
\end_layout

\end_inset


\family default
 and 
\family typewriter
strerror_l
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_l
\end_layout

\end_inset


\family default
 return a pointer to the error message string.
 If an error occurs, the error code is stored in 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
.
 
\family typewriter
strerror_r
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strerror_r
\end_layout

\end_inset


\family default
 returns zero upon successful completion.
 If an error occurs, the error code is stored in 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 and the error code is returned.
 These functions are defined in 
\family typewriter
<string.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<string.h>
\end_layout

\end_inset


\family default
.
\begin_inset listings
lstparams "language=C,numbers=left,breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:strerror"

\end_inset

strerror.c - prints out errors names.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File strerror.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* strerror program.
 */
\end_layout

\begin_layout Plain Layout

#define FOREVER for(;;)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions prototypes.
 */
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i;
\end_layout

\begin_layout Plain Layout

	long int ret;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* */
\end_layout

\begin_layout Plain Layout

	ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	for(i = 0; i <= EPROTO; i++)
\end_layout

\begin_layout Plain Layout

		fprintf(stderr, "Error %d = %s
\backslash
n", i, strerror(i));
\end_layout

\begin_layout Plain Layout

	ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

	exit(ret);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of strerror.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:strsignal"

\end_inset

The 
\family typewriter
strsignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strsignal
\end_layout

\end_inset


\family default
 routine.
\end_layout

\begin_layout Standard
The 
\family typewriter
strsignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strsignal
\end_layout

\end_inset


\family default
 function returns a pointer to the string describing the signal specified
 in the first argument.
 The array pointed to is not to be modified by the program, but may be overwritt
en by subsequent calls to 
\family typewriter
strsignal
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
strsignal
\end_layout

\end_inset


\family default
.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:strsignal"

\end_inset

strsignal - program to list signals names.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File strsignal.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <errno.h>
\end_layout

\begin_layout Plain Layout

#include <signal.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* strsignal program.
 */
\end_layout

\begin_layout Plain Layout

#define FOREVER for(;;)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions prototypes.
 */
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	int i;
\end_layout

\begin_layout Plain Layout

	long int ret;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* */
\end_layout

\begin_layout Plain Layout

	ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	for(i = SIGHUP; i <= SIGTHR; i++)
\end_layout

\begin_layout Plain Layout

		printf("Signal %d = %s
\backslash
n", i, strsignal(i));
\end_layout

\begin_layout Plain Layout

	ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

	exit(ret);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of strsignal.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:sorting-arrays-in-memory"

\end_inset

Sorting Arrays in Memory.
\end_layout

\begin_layout Standard
OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 provides three functions for sorting arrays: 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
, 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 and 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
.
 They are defined in 
\family typewriter
<stdlib.h>
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
<stdlib.h>
\end_layout

\end_inset


\family default
 file and take four parameters.
 The 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 function is a modified partition-exchange sort, or quicksort.
 The 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 function is a modified selection sort.
 The 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 function is a modified merge sort with exponential search intended for
 sorting data with pre-existing order.
 The 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 and 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 functions sort an array of a number of objects specified in the second
 argument, the initial member of which is pointed to by the first argument.
 The size of each object is specified by the third argument.
 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 behaves similarly, but requires that the third argument be greater than
 
\family typewriter
sizeof(void *) / 2
\family default
.
 The contents of the array pointed by the first argument are sorted in ascending
 order according to a comparison function pointed to by the fourth argument,
 which requires two arguments pointing to the objects being compared.
 The comparison function must return an 
\family typewriter
int
\family default
 less than, equal to, or greater than zero if the first argument is considered
 to be respectively less than, equal to, or greater than the second.
 The functions 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 and 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 are not stable, that is, if two members compare as equal, their order in
 the sorted array is undefined.
 The function 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 is stable.
 The 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 function is an implementation of C.
 A.
 R.
 Hoare's 
\shape italic
quicksort
\shape default
 algorithm, a variant of partition-exchange sorting; in particular, see
 D.
 E.
 Knuth's Algorithm Q.
 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 takes 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 average time.
 This implementation uses median selection to avoid its 
\begin_inset Formula $O\left(n^{2}\right)$
\end_inset

 worst-case behavior and will fall back to 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 if the recursion depth exceeds 
\begin_inset Formula $2\lg n$
\end_inset

.
 The 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 function is an implementation of J.
 W.
 J.
 William's 
\shape italic
heapsort
\shape default
 algorithm, a variant of selection sorting; in particular, see D.
 E.
 Knuth's Algorithm H.
 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 takes 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

 worst-case time.
 This implementation of 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 is implemented without recursive function calls.
 The function 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 requires additional memory of second argument value * third argument value
 bytes; it should be used only when space is not at a premium.
 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 is optimized for data with pre-existing order; its worst case time is 
\begin_inset Formula $O\left(n\lg n\right)$
\end_inset

; its best case is 
\begin_inset Formula $O\left(n\right)$
\end_inset

.
 Normally, 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
 is faster than 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
, which is faster than 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
.
 Memory availability and pre-existing order in the data can make this untrue.
 The 
\family typewriter
heapsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
heapsort
\end_layout

\end_inset


\family default
 and 
\family typewriter
mergesort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
mergesort
\end_layout

\end_inset


\family default
 functions return the value 0 if successful; otherwise the value -1 is returned
 and the global variable 
\family typewriter
errno
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
errno
\end_layout

\end_inset


\family default
 is set to indicate the error.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "c:sort"
plural "false"
caps "false"
noprefix "false"

\end_inset

 show an application of 
\family typewriter
qsort
\begin_inset Index idx
status open

\begin_layout Plain Layout

\family typewriter
qsort
\end_layout

\end_inset


\family default
.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:sort"

\end_inset

sort - a program to show qsort capability.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File sort.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char *array[] = { "XX", "YYY", "Z" };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define N (sizeof(array) / sizeof(array[ 0 ]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions prototypes.
 */
\end_layout

\begin_layout Plain Layout

int cmp(const void *, const void *);
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	long int ret = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

	size_t i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* */
\end_layout

\begin_layout Plain Layout

	qsort(array, N, sizeof(array[0]), cmp);
\end_layout

\begin_layout Plain Layout

	for(i = 0; i < N; i++)
\end_layout

\begin_layout Plain Layout

		printf("%s
\backslash
n", array[i]);
\end_layout

\begin_layout Plain Layout

	ret = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

	exit(ret);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/*
\end_layout

\begin_layout Plain Layout

 * cmp -- comparing elements function.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

int cmp(const void *a, const void *b)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	/*
\end_layout

\begin_layout Plain Layout

	 * a and b point to elements of the array.
\end_layout

\begin_layout Plain Layout

	 * Cast and dereference to obtain the actual elements,
\end_layout

\begin_layout Plain Layout

	 * which are also pointers in this case.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

	size_t lena = strlen(*(const char **) a);
\end_layout

\begin_layout Plain Layout

	size_t lenb = strlen(*(const char **) b);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/*
\end_layout

\begin_layout Plain Layout

	 * Do not subtract the lengths.
 The difference between values
\end_layout

\begin_layout Plain Layout

	 * cannot be represented by an int.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

	return lena < lenb ? -1 : lena > lenb;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of sort.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:generating-random-numbers"

\end_inset

Generating Random Numbers.
\end_layout

\begin_layout Standard
In computers games and security, to generate a random sequence of integer
 numbers is very important.
 Every modern operating systems own a set of functions to generate such
 sequences.
 OpenBSD is no exception, it has got several system calls to achieve this
 task:
\end_layout

\begin_layout Itemize
srand;
\end_layout

\begin_layout Itemize
srand_deterministic;
\end_layout

\begin_layout Itemize
rand;
\end_layout

\begin_layout Itemize
rand_r;
\end_layout

\begin_layout Itemize
arc4random;
\end_layout

\begin_layout Itemize
rand48;
\end_layout

\begin_layout Itemize
random.
\end_layout

\begin_layout Standard
then rand and srand family of functions are used for compatibility purposes.
 Since the standard tells that the interface must return deterministic results,
 OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 choosen to change this behaviour to return non-deterministic results by
 default.
 To satisfy portable code, 
\family typewriter
srand()
\family default
 may be called to initialize the subsystem.
 In OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 the seed variable is ignored, and strong random number results will be
 provided from 
\shape italic
arc4random
\shape default
(3).
 In other systems, the seed variable primes a simplistic deterministic algorithm.
 If the standardized behavior is required 
\family typewriter
srand_deterministic()
\family default
 can be substituted for 
\family typewriter
srand()
\family default
, then subsequent 
\family typewriter
rand()
\family default
 calls will return results using the deterministic algorithm.
 The deterministic sequence algorithm changed a number of times since original
 development, is underspecified, and should not be relied upon to remain
 consistent between platforms and over time.
 The 
\family typewriter
rand()
\family default
 function returns a result in the range of 0 to RAND_MAX
\begin_inset Index idx
status open

\begin_layout Plain Layout
RAND_MAX
\end_layout

\end_inset

.
 By default, this result comes from 
\shape italic
arc4random
\shape default
(3).
 If 
\family typewriter
srand_deterministic()
\family default
 was called, the result will be computed using the deterministic algorithm.
 The 
\family typewriter
rand_r()
\family default
 function is a thread-safe version of 
\family typewriter
rand()
\family default
.
 Storage for the seed must be provided through the seed argument, and needs
 to have been initialized by the caller.
 It always operates using the deterministic algorithm.
 
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:random"

\end_inset

random - a program to guess random integer numbers.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File random.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define GUESSES_COUNT 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes.
 */
\end_layout

\begin_layout Plain Layout

int again(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  long int nReturnValue = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

  char c;
\end_layout

\begin_layout Plain Layout

  int g, i, n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  srand(0);
\end_layout

\begin_layout Plain Layout

  n = rand();
\end_layout

\begin_layout Plain Layout

  for(i = 0; i < GUESSES_COUNT; i++) {
\end_layout

\begin_layout Plain Layout

    printf("Guess #%d: what is the number? ", i + 1);
\end_layout

\begin_layout Plain Layout

    scanf("%d", &g);
\end_layout

\begin_layout Plain Layout

    if(g < n)
\end_layout

\begin_layout Plain Layout

      printf("your guess is lower than the choosen number.
\backslash
n");
\end_layout

\begin_layout Plain Layout

    else if(g > n)
\end_layout

\begin_layout Plain Layout

      printf("your guess is higher that the choosen number.
\backslash
n");
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      printf("Correct the number %d is the choosen one! You it took you
 %d tries.
\backslash
n", n, i);
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if((i + 1) < GUESSES_COUNT)
\end_layout

\begin_layout Plain Layout

      if(again() == 0)
\end_layout

\begin_layout Plain Layout

	i = GUESSES_COUNT;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(i >= GUESSES_COUNT)
\end_layout

\begin_layout Plain Layout

    printf("The number to guess was %d
\backslash
n.", n);
\end_layout

\begin_layout Plain Layout

  exit(nReturnValue);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int again(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  char answer[ 4 ];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  printf("do you want to continue? ");
\end_layout

\begin_layout Plain Layout

  scanf("%s", answer);
\end_layout

\begin_layout Plain Layout

  if(strncmp(answer, "yes", 3) == 0)
\end_layout

\begin_layout Plain Layout

    return 1;
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of random.c file.
 */
\end_layout

\end_inset

during compilation of random.c the compiler emits this specific warning:
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

[ LD ] egcc/random ld: warning: random.c:22(egcc/random.o:(main)): warning:
 rand() may return deterministic values, is that what you want?
\end_layout

\end_inset

alas the man page for rand() reports a non-deterministic behaviour, we can
 use a different approach with:
\end_layout

\begin_layout Itemize
arc4random;
\end_layout

\begin_layout Itemize
arc4random_buf;
\end_layout

\begin_layout Itemize
arc4random_uniform;
\end_layout

\begin_layout Standard
functions family.
 These provide higher quality data than those described in 
\shape italic
rand
\shape default
(3), 
\shape italic
random
\shape default
(3) and 
\shape italic
rand48
\shape default
(3).
 OpenBSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
OpenBSD
\end_layout

\end_inset

 man pages 
\shape italic
arc4random
\shape default
(3), encourages the use of this functions for all random number generation.
 Reasons for that are mostly:
\end_layout

\begin_layout Itemize
interface quality;
\end_layout

\begin_layout Itemize
portability;
\end_layout

\begin_layout Itemize
standardization;
\end_layout

\begin_layout Itemize
availability.
\end_layout

\begin_layout Standard
Those functions can be called in 
\shape italic
pthreads
\shape default
(3) and 
\shape italic
chroot
\shape default
(2) environment.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:random2"

\end_inset

random2 - a program to guess random integer numbers using arc4random family
 functions.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File random2.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdint.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define GUESSES_COUNT 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes.
 */
\end_layout

\begin_layout Plain Layout

int again(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  long int nReturnValue = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

  char c;
\end_layout

\begin_layout Plain Layout

  int g, i;
\end_layout

\begin_layout Plain Layout

  uint32_t n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  n = arc4random();
\end_layout

\begin_layout Plain Layout

  for(i = 0; i < GUESSES_COUNT; i++) {
\end_layout

\begin_layout Plain Layout

    printf("Guess #%d: what is the number? ", i + 1);
\end_layout

\begin_layout Plain Layout

    scanf("%d", &g);
\end_layout

\begin_layout Plain Layout

    if(g < n)
\end_layout

\begin_layout Plain Layout

      printf("your guess is lower than the choosen number.
\backslash
n");
\end_layout

\begin_layout Plain Layout

    else if(g > n)
\end_layout

\begin_layout Plain Layout

      printf("your guess is higher that the choosen number.
\backslash
n");
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

      printf("Correct the number %d is the choosen one! You it took you
 %d tries.
\backslash
n", n, i);
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if((i + 1) < GUESSES_COUNT)
\end_layout

\begin_layout Plain Layout

      if(again() == 0)
\end_layout

\begin_layout Plain Layout

	i = GUESSES_COUNT;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(i >= GUESSES_COUNT)
\end_layout

\begin_layout Plain Layout

    printf("The number to guess was %d
\backslash
n.", n);
\end_layout

\begin_layout Plain Layout

  exit(nReturnValue);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int again(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  char answer[ 4 ];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  printf("do you want to continue? ");
\end_layout

\begin_layout Plain Layout

  scanf("%s", answer);
\end_layout

\begin_layout Plain Layout

  if(strncmp(answer, "yes", 3) == 0)
\end_layout

\begin_layout Plain Layout

    return 1;
\end_layout

\begin_layout Plain Layout

  else
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of random2.c file.
 */
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:getting-parameters-from-console"

\end_inset

Getting Parameters from Console.
\end_layout

\begin_layout Subsection
argc and argv.
\end_layout

\begin_layout Standard
People using programs by the console are aware of the possibility to provide
 additional informations to the programs themselves.
 Those informations are entered following the program name, such as:
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ ls -al
\end_layout

\end_inset

where -al are called switches or options.
 C language has got a mechanism to provide those informations to the called
 program via two global variables: argc and argv.
 The first is the count of the informations which are separated one from
 another by a space plus the program name.
 argv is an array of strings which holds every options.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:arguments"

\end_inset

arguments - a program to show passed parameters from console.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File arguments.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdint.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Function prototypes.
 */
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main(int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  long int nReturnValue = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

  char *p;
\end_layout

\begin_layout Plain Layout

  int i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  printf("You provided %d options:
\backslash
n", argc);
\end_layout

\begin_layout Plain Layout

  for(i = 0; i < argc; i++)
\end_layout

\begin_layout Plain Layout

    printf("option #%d: %s
\backslash
n", i, argv[ i ]);
\end_layout

\begin_layout Plain Layout

  exit(nReturnValue);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of arguments.c file.
 */
\end_layout

\end_inset

the UNIX conventions are a bit complex, they are listed in The Open Group
 Base Specifications Issue 7, 2018 edition IEEE Std 1003.1-2017 (Revision
 of IEEE Std 1003.1-2008) which we will report in the following.
\end_layout

\begin_layout Subsection
Utility Conventions.
\end_layout

\begin_layout Subsubsection
Utility Argument Syntax.
\end_layout

\begin_layout Standard
This section describes the argument syntax of the standard utilities and
 introduces terminology used throughout POSIX.1-2017 for describing the arguments
 processed by the utilities.
 Within POSIX.1-2017, a special notation is used for describing the syntax
 of a utility's arguments.
 Unless otherwise noted, all utility descriptions use this notation, which
 is illustrated by this example (see XCU Simple Commands):
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name[-a][-b][-c option_argument] [-d|-e][-f[option_argument]][operand...]
\end_layout

\end_inset

The notation used for the SYNOPSIS sections imposes requirements on the
 implementors of the standard utilities and provides a simple reference
 for the application developer or system user.
 
\end_layout

\begin_layout Enumerate
The utility in the example is named utility_name.
 It is followed by options, option-arguments, and operands.
 The arguments that consist of <hyphen-minus> characters and single letters
 or digits, such as 'a', are known as "options" (or, historically, "flags").
 Certain options are followed by an "option-argument", as shown with [ -c
 option_argument].
 The arguments following the last options and option-arguments are named
 "operands".
 
\end_layout

\begin_layout Enumerate
Option-arguments are shown separated from their options by <blank> characters,
 except when the option-argument is enclosed in the '[' and ']' notation
 to indicate that it is optional.
 This reflects the situation in which an optional option-argument (if present)
 is included within the same argument string as the option; for a mandatory
 option-argument, it is the next argument.
 The Utility Syntax Guidelines in Utility Syntax Guidelines require that
 the option be a separate argument from its option-argument and that option-argu
ments not be optional, but there are some exceptions in POSIX.1-2017 to ensure
 continued operation of historical applications:
\end_layout

\begin_deeper
\begin_layout Enumerate
If the SYNOPSIS of a standard utility shows an option with a mandatory option-ar
gument (as with [ -c option_argument] in the example), a conforming application
 shall use separate arguments for that option and its option-argument.
 However, a conforming implementation shall also permit applications to
 specify the option and option-argument in the same argument string without
 intervening <blank> characters.
\end_layout

\begin_layout Enumerate
If the SYNOPSIS shows an optional option-argument (as with [ -f[ option_argument
]] in the example), a conforming application shall place any option-argument
 for that option directly adjacent to the option in the same argument string,
 without intervening <blank> characters.
 If the utility receives an argument containing only the option, it shall
 behave as specified in its description for an omitted option-argument;
 it shall not treat the next argument (if any) as the option-argument for
 that option.
\end_layout

\end_deeper
\begin_layout Enumerate
Options are usually listed in alphabetical order unless this would make
 the utility description more confusing.
 There are no implied relationships between the options based upon the order
 in which they appear, unless otherwise stated in the OPTIONS section, or
 unless the exception in Guideline 11 of Utility Syntax Guidelines applies.
 If an option that does not have option-arguments is repeated, the results
 are undefined, unless otherwise stated.
\end_layout

\begin_layout Enumerate
Frequently, names of parameters that require substitution by actual values
 are shown with embedded <underscore> characters.
 Alternatively, parameters are shown as follows:
\end_layout

\begin_deeper
\begin_layout Standard

\family typewriter
<parameter name>
\end_layout

\begin_layout Standard
The angle brackets are used for the symbolic grouping of a phrase representing
 a single parameter and conforming applications shall not include them in
 data submitted to the utility.
\end_layout

\end_deeper
\begin_layout Enumerate
When a utility has only a few permissible options, they are sometimes shown
 individually, as in the example.
 Utilities with many flags generally show all of the individual flags (that
 do not take option-arguments) grouped, as in:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name [-abcDxyz][-p arg][operand]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Utilities with very complex arguments may be shown as follows:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name [options][operands]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Unless otherwise specified, whenever an operand or option-argument is, or
 contains, a numeric value:
\end_layout

\begin_deeper
\begin_layout Itemize
The number is interpreted as a decimal integer.
\end_layout

\begin_layout Itemize
Numerals in the range 0 to 2147483647 are syntactically recognized as numeric
 values.
\end_layout

\begin_layout Itemize
When the utility description states that it accepts negative numbers as
 operands or option-arguments, numerals in the range -2147483647 to 2147483647
 are syntactically recognized as numeric values.
\end_layout

\begin_layout Itemize
When the utility description states that the number is a file size-related
 value (such as a file size or offset, line number, or block count), numerals
 in the range 0 to the maximum file size supported by the implementation
 are syntactically recognized as numeric values (see XCU Considerations
 for Utilities in Support of Files of Arbitrary Size).
 Where negative values are permitted, any value in the range -(maximum file
 size) to the maximum file size is accepted.
\end_layout

\begin_layout Itemize
Ranges greater than those listed here are allowed.
\end_layout

\begin_layout Standard
This does not mean that all numbers within the allowable range are necessarily
 semantically correct.
 A standard utility that accepts an option-argument or operand that is to
 be interpreted as a number, and for which a range of values smaller than
 that shown above is permitted by the POSIX.1-2017, describes that smaller
 range along with the description of the option-argument or operand.
 If an error is generated, the utility's diagnostic message shall indicate
 that the value is out of the supported range, not that it is syntactically
 incorrect.
\end_layout

\end_deeper
\begin_layout Enumerate
Arguments or option-arguments enclosed in the '[' and ']' notation are optional
 and can be omitted.
 Conforming applications shall not include the '[' and ']' symbols in data
 submitted to the utility.
\end_layout

\begin_layout Enumerate
Arguments separated by the '|' ( <vertical-line>) bar notation are mutually-excl
usive.
 Conforming applications shall not include the '|' symbol in data submitted
 to the utility.
 Alternatively, mutually-exclusive options and operands may be listed with
 multiple synopsis lines.
\end_layout

\begin_deeper
\begin_layout Standard
For example:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name -d[-a][-c option_argument][operand...] 
\end_layout

\begin_layout Plain Layout

$ utility_name[-a][-b][operand...]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When multiple synopsis lines are given for a utility, it is an indication
 that the utility has mutually-exclusive arguments.
 These mutually-exclusive arguments alter the functionality of the utility
 so that only certain other arguments are valid in combination with one
 of the mutually-exclusive arguments.
 Only one of the mutually-exclusive arguments is allowed for invocation
 of the utility.
 Unless otherwise stated in an accompanying OPTIONS section, the relationships
 between arguments depicted in the SYNOPSIS sections are mandatory requirements
 placed on conforming applications.
 The use of conflicting mutually-exclusive arguments produces undefined
 results, unless a utility description specifies otherwise.
 When an option is shown without the '[' and ']' brackets, it means that
 option is required for that version of the SYNOPSIS.
 However, it is not required to be the first argument, as shown in the example
 above, unless otherwise stated.
\end_layout

\end_deeper
\begin_layout Enumerate
Ellipses ( "..." ) are used to denote that one or more occurrences of an operand
 are allowed.
 When an option or an operand followed by ellipses is enclosed in brackets,
 zero or more options or operands can be specified.
 The form:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name [-g option_argument]...[operand...]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
indicates that multiple occurrences of the option and its option-argument
 preceding the ellipses are valid, with semantics as indicated in the OPTIONS
 section of the utility.
 (See also Guideline 11 in Utility Syntax Guidelines .)
\end_layout

\begin_layout Standard
The form:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

$ utility_name -f option_argument [-f option_argument]...
 [operand...]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
indicates that the -f option is required to appear at least once and may
 appear multiple times.
\end_layout

\end_deeper
\begin_layout Enumerate
When the synopsis line is too long to be printed on a single line in the
 Shell and Utilities volume of POSIX.1-2017, the indented lines following
 the initial line are continuation lines.
 An actual use of the command would appear on a single logical line.
\end_layout

\begin_layout Subsubsection
Utility Syntax Guidelines.
\end_layout

\begin_layout Standard
The following guidelines are established for the naming of utilities and
 for the specification of options, option-arguments, and operands.
 The getopt() function in the System Interfaces volume of POSIX.1-2017 assists
 utilities in handling options and operands that conform to these guidelines.
 Operands and option-arguments can contain characters not specified in the
 portable character set.
 The guidelines are intended to provide guidance to the authors of future
 utilities, such as those written specific to a local system or that are
 components of a larger application.
 Some of the standard utilities do not conform to all of these guidelines;
 in those cases, the OPTIONS sections describe the deviations:
\end_layout

\begin_layout Enumerate
Utility names should be between two and nine characters, inclusive.
\end_layout

\begin_layout Enumerate
Utility names should include lowercase letters (the lower character classificati
on) and digits only from the portable character set.
\end_layout

\begin_layout Enumerate
Each option name should be a single alphanumeric character (the alnum character
 classification) from the portable character set.
 The -W (capital-W) option shall be reserved for vendor options.
 Multi-digit options should not be allowed.
\end_layout

\begin_layout Enumerate
All options should be preceded by the '-' delimiter character.
\end_layout

\begin_layout Enumerate
One or more options without option-arguments, followed by at most one option
 that takes an option-argument, should be accepted when grouped behind one
 '-' delimiter.
\end_layout

\begin_layout Enumerate
Each option and option-argument should be a separate argument, except as
 noted in Utility Argument Syntax, item (2).
\end_layout

\begin_layout Enumerate
Option-arguments should not be optional.
\end_layout

\begin_layout Enumerate
When multiple option-arguments are specified to follow a single option,
 they should be presented as a single argument, using <comma> characters
 within that argument or <blank> characters within that argument to separate
 them.
\end_layout

\begin_layout Enumerate
All options should precede operands on the command line.
\end_layout

\begin_layout Enumerate
The first -- argument that is not an option-argument should be accepted
 as a delimiter indicating the end of options.
 Any following arguments should be treated as operands, even if they begin
 with the '-' character.
\end_layout

\begin_layout Enumerate
The order of different options relative to one another should not matter,
 unless the options are documented as mutually-exclusive and such an option
 is documented to override any incompatible options preceding it.
 If an option that has option-arguments is repeated, the option and option-argum
ent combinations should be interpreted in the order specified on the command
 line.
\end_layout

\begin_layout Enumerate
The order of operands may matter and position-related interpretations should
 be determined on a utility-specific basis.
\end_layout

\begin_layout Enumerate
For utilities that use operands to represent files to be opened for either
 reading or writing, the '-' operand should be used to mean only standard
 input (or standard output when it is clear from context that an output
 file is being specified) or a file named -.
\end_layout

\begin_layout Enumerate
If an argument can be identified according to Guidelines 3 through 10 as
 an option, or as a group of options without option-arguments behind one
 '-' delimiter, then it should be treated as such.
\end_layout

\begin_layout Standard
The utilities in the Shell and Utilities volume of POSIX.1-2017 that claim
 conformance to these guidelines shall conform completely to these guidelines
 as if these guidelines contained the term "shall" instead of "should".
 On some implementations, the utilities accept usage in violation of these
 guidelines for backwards-compatibility as well as accepting the required
 form.
 Where a utility described in the Shell and Utilities volume of POSIX.1-2017
 as conforming to these guidelines is required to accept, or not to accept,
 the operand '-' to mean standard input or output, this usage is explained
 in the OPERANDS section.
 Otherwise, if such a utility uses operands to represent files, it is implementa
tion-defined whether the operand '-' stands for standard input (or standard
 output), or for a file named -.
 It is recommended that all future utilities and applications use these
 guidelines to enhance user portability.
 The fact that some historical utilities could not be changed (to avoid
 breaking existing applications) should not deter this future goal.
\end_layout

\begin_layout Subsection
The getopt interface.
\end_layout

\begin_layout Standard
The standard getopt interface uses the function
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

int getopt(int argc, char * const argv[], const char *optstring);
\end_layout

\end_inset

and the global variables
\begin_inset listings
lstparams "language=C,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

extern char *optarg;
\end_layout

\begin_layout Plain Layout

extern int optind;
\end_layout

\begin_layout Plain Layout

extern int opterr;
\end_layout

\begin_layout Plain Layout

extern int optopt;
\end_layout

\end_inset

optarg is a pointer to the current option to parse, if it is not NULL it
 can be used to parse again.
 optind is and index which holds the current position in the argv array,
 opterr is a boolean switch indicating if getopt should emits error messages,
 and finally optopt which holds thje value of the first unrecognized characters
 for option.
 The following program show the getopt interface usage.
\begin_inset listings
lstparams "language=C,numbers=left,basicstyle={\ttfamily},breaklines=true,tabsize=2"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "c:arguments2"

\end_inset

arguments2 - a program to show getopt interface usage.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

/* -*- mode: c; -*- */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* File arguments2.c.
 */
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

#include <stdlib.h>
\end_layout

\begin_layout Plain Layout

#include <stdint.h>
\end_layout

\begin_layout Plain Layout

#include <string.h>
\end_layout

\begin_layout Plain Layout

#include <unistd.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Functions prototypes.
 */
\end_layout

\begin_layout Plain Layout

int main(int, char *[]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Main function.
 */
\end_layout

\begin_layout Plain Layout

int main (int argc, char *argv[])
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int c;
\end_layout

\begin_layout Plain Layout

  int digit_optind = 0;
\end_layout

\begin_layout Plain Layout

  int aopt = 0, bopt = 0;
\end_layout

\begin_layout Plain Layout

  int nReturnValue = EXIT_FAILURE;
\end_layout

\begin_layout Plain Layout

  char *copt = 0, *dopt = 0;
\end_layout

\begin_layout Plain Layout

  const char options[] = "abc:d:h012";
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* */
\end_layout

\begin_layout Plain Layout

  while ((c = getopt(argc, argv, options)) != -1) {
\end_layout

\begin_layout Plain Layout

    int this_option_optind = optind ? optind : 1;
\end_layout

\begin_layout Plain Layout

    switch(c) {
\end_layout

\begin_layout Plain Layout

    case '0':
\end_layout

\begin_layout Plain Layout

    case '1':
\end_layout

\begin_layout Plain Layout

    case '2':
\end_layout

\begin_layout Plain Layout

      if(digit_optind != 0 && digit_optind != this_option_optind) {
\end_layout

\begin_layout Plain Layout

	printf ("digits occur in two different argv-elements.
\backslash
n");
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      digit_optind = this_option_optind;
\end_layout

\begin_layout Plain Layout

      printf ("option %c
\backslash
n", c);
\end_layout

\begin_layout Plain Layout

      nReturnValue = EXIT_SUCCESS;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    case 'a':
\end_layout

\begin_layout Plain Layout

      printf ("option a
\backslash
n");
\end_layout

\begin_layout Plain Layout

      aopt = 1;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    case 'b':
\end_layout

\begin_layout Plain Layout

      printf ("option b
\backslash
n");
\end_layout

\begin_layout Plain Layout

      bopt = 1;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    case 'c':
\end_layout

\begin_layout Plain Layout

      printf ("option c with value '%s'
\backslash
n", optarg);
\end_layout

\begin_layout Plain Layout

      copt = optarg;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    case 'd':
\end_layout

\begin_layout Plain Layout

      printf ("option d with value '%s'
\backslash
n", optarg);
\end_layout

\begin_layout Plain Layout

      dopt = optarg;
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    case 'h':
\end_layout

\begin_layout Plain Layout

      printf("%s [-abcd argument] ...
\backslash
n", argv[ 0 ]);
\end_layout

\begin_layout Plain Layout

      printf("%s [ -h ]
\backslash
n", argv[ 0 ]);
\end_layout

\begin_layout Plain Layout

      exit(nReturnValue);
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    case '?':
\end_layout

\begin_layout Plain Layout

      break;
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

    default:
\end_layout

\begin_layout Plain Layout

      printf ("?? getopt returned character code 0%o ??
\backslash
n", c);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(optind < argc) {
\end_layout

\begin_layout Plain Layout

    printf ("non-option ARGV-elements: ");
\end_layout

\begin_layout Plain Layout

    while (optind < argc) {
\end_layout

\begin_layout Plain Layout

      printf ("%s ", argv[optind++]);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    printf ("
\backslash
n");
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  exit(nReturnValue);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* End of arguments2.c file.
 */
\end_layout

\end_inset


\end_layout

\end_body
\end_document
